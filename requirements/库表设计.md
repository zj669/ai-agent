
### 第一维度：Agent 管理（设计态）

这一层负责存储用户画出来的图，以及发布的版本控制。

#### 1. `agent_info` (Agent 信息主表)

* **作用**：存储 Agent 的基础信息以及**草稿状态**的工作流定义。用户在画布上编辑但未发布的数据存这里。
* **关键字段**：
* `id`: 主键
* `user_id`: 归属用户
* `status`: 状态 (草稿/已发布/下线)
* `graph_json`: **核心字段**，存储草稿版的 DAG 图结构（包含 nodes, edges, schemaPolicy）。
* `published_version_id`: 指向当前线上使用的版本 ID。



#### 2. `agent_version` (Agent 版本发布表)

* **作用**：存储**已发布**的 Agent 快照。一旦发布，版本不可修改，确保线上流量不受草稿编辑影响。
* **关键字段**：
* `id`: 主键
* `agent_id`: 关联主表
* `version`: 版本号 (1, 2, 3...)
* `graph_snapshot`: **核心字段**，发布那一刻的 `graph_json` 完整副本（不可变）。



---

### 第二维度：动态配置（元数据）

用于控制前端节点弹窗显示什么配置项。

#### 3. `node_template` (节点模版/类型表)

* **作用**：定义系统支持哪些节点类型（如：LLM节点、知识库检索、意图识别）。同时定义该节点的**结构策略**（能否删减输入输出）。
* **关键字段**：
* `id`: 主键
* `type_code`: 类型编码 (例如 "LLM", "MCP_TOOL", "RAG")
* `name`: 显示名称
* `default_schema_policy`: **核心字段**，JSON 格式。定义该节点是否允许用户新增/删除 Input 或 Output 结构。
* `initial_schema`: JSON 格式。定义节点初始化时默认的输入输出参数（含 `isSystem=true` 的字段）。



#### 4. `sys_config_field_def` (配置字段字典表)

* **作用**：**对应你提供的图片**。定义所有可用的原子配置项。
* **关键字段**：
* `id`: 主键
* `field_key`: 字段键名 (例如 "temperature", "model_name")
* `field_label`: 前端显示标签
* `field_type`: 控件类型 (text, select, boolean, json, number)
* `options`: 下拉选项数据 (JSON)
* `default_value`: 全局默认值



#### 5. `node_template_config_mapping` (节点与配置关联表)

* **作用**：**连接表**。定义“LLM 节点”具体由“字典表”中的哪些字段组成。
* **关键字段**：
* `id`: 主键
* `node_template_id`: 关联节点模版
* `field_def_id`: 关联配置字段
* `group_name`: 分组名称 (例如 "基础参数", "高级设置")
* `sort_order`: 在该节点表单中的排序
* `override_default`: (可选) 覆盖该节点特定的默认值



这是基于**高性能读写分离（列表页 0 Join）** 策略设计的运行时数据库表结构。

此方案的核心在于：**在主表中冗余存储“一问一答”的核心文本**，使得查询聊天记录列表时极其快速；而“深度思考过程”和“调试详情”则存放在大数据量的日志表中，按需异步加载。

共需要建立 **3 张** 核心运行时表：

### 1. `workflow_execution` (执行实例表 - 高性能版)

* **表作用**：
* 记录每一次对话任务的完整生命周期。
* **高性能优化点**：直接存储用户的提问和 Agent 的最终回复。前端渲染聊天窗口的“主列表”时，**只需要查这一张表**，不需要关联查询任何其他表。


* **关键字段**：
* `id` (PK): 执行ID (UUID)。
* `conversation_id` (Index): 所属会话ID。
* `agent_version_id`: 关联的 Agent 版本ID。
* `status`: 状态 (`RUNNING`, `SUCCEEDED`, `FAILED`, `PAUSED`)。
* **`user_query` (冗余)**: **[核心]** 用户发送的消息文本快照。避免去查消息表。
* **`final_response` (冗余)**: **[核心]** Agent 执行结束后的最终回复文本（即所有 `MESSAGE` 类型节点的输出拼接）。列表页直接读它。
* **`token_usage`**: 本次消耗的总 Token 数（计费展示用）。
* `created_at`: 开始时间（用于排序）。
* `finished_at`: 结束时间（用于计算总耗时）。



### 2. `workflow_node_execution_log` (节点流水日志表)

* **表作用**：
* 存储 DAG 图中每个节点的执行细节。
* **按需加载**：当用户点击“查看思考过程”或开启“调试模式”时，才通过 API 查询此表。
* **UI 驱动**：通过 `render_mode` 字段告诉前端怎么画图。


* **关键字段**：
* `id` (PK): 主键。
* `execution_id` (Index): 关联执行实例。
* `node_id`: 节点ID (如 `step-1-search`)。
* `node_name`: 节点名称 (如 "网络搜索")。
* `node_type`: 节点类型 (`LLM`, `TOOL`, `CODE`)。
* **`render_mode`**: **[核心]** 可见性策略。
* `HIDDEN`: 只有调试模式才查得到。
* `THOUGHT`: 前端渲染为“深度思考”折叠框。
* `MESSAGE`: 最终回复的一部分。


* **`summary`**: **[核心]** 思考过程的简短摘要（用于在折叠框标题上显示，如“正在搜索 xxxx...”）。
* `content`: 流式输出的完整文本内容。
* **`inputs`**: **[调试]** 完整输入 JSON (调试模式用)。
* **`outputs`**: **[调试]** 完整输出 JSON (调试模式用)。
* `status`: 0-执行中, 1-成功, 2-失败。
* `duration_ms`: 耗时。



### 3. `execution_checkpoint` (断点恢复表)

* **表作用**：
* 用于“暂停/继续”场景（如人工审批）或系统崩溃后的恢复。
* 数据量相对较小，只存储必要的存档点。


* **关键字段**：
* `id` (PK): 主键。
* `execution_id` (Index): 关联执行实例。
* `node_id`: 存档时刚执行完的节点ID。
* **`global_context`**: **[核心]** 整个工作流的变量池快照 JSON（包含之前所有节点的产出）。
* `executed_nodes`: 已执行节点ID列表（避免恢复后重复执行）。
* `created_at`: 存档时间。



---

### 总结：高性能查询策略

1. **用户打开聊天窗口（默认视图）**：
* **SQL**: `SELECT user_query, final_response, status FROM workflow_execution WHERE conversation_id = ?`
* **性能**: 极快，单表查询，无大字段传输。
* **展示**: 显示一问一答，类似于微信聊天。


2. **用户点击“深度思考”或“调试模式”**：
* **SQL**: `SELECT node_name, render_mode, content, inputs, outputs FROM workflow_node_execution_log WHERE execution_id = ?`
* **性能**: 仅在用户主动交互时触发，不影响首屏加载速度。
* **展示**: 展开折叠框，或显示侧边栏调试信息。