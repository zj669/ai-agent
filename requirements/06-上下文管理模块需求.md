# AI-Agent 上下文管理模块需求文档

## 1. 模块概述

### 1.1 模块名称
上下文管理模块（Context Management）

### 1.2 模块定位
工作流编排模块的核心支撑 - 管理执行上下文与检查点

### 1.3 核心价值
- 提供节点间状态共享能力
- 支持执行上下文快照保存与恢复
- 实现断点续执行功能
- 支持状态数据的安全修改

---

## 2. 功能需求

### 2.1 获取执行快照

**功能描述**：获取指定会话的当前执行上下文快照。

**业务规则**：
- 返回最新的检查点数据
- 包含当前节点、执行状态、状态数据
- 包含已执行节点的历史记录

**输入参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| conversationId | String | 是 | 会话ID |

**输出**：
```java
ExecutionContextSnapshot {
    conversationId: String        // 会话ID
    currentNodeId: String         // 当前节点ID
    currentNodeName: String       // 当前节点名称
    status: String                // 执行状态
    stateData: Map<String, Object> // 状态数据
    executionHistory: List<Map>   // 执行历史
    timestamp: Long               // 快照时间戳
}
```

---

### 2.2 更新执行快照

**功能描述**：更新指定会话的执行上下文状态数据。

**业务规则**：
- 仅允许在 PAUSED 状态更新
- 增量更新（合并而非覆盖）
- 更新后持久化到存储

**输入参数**：
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| conversationId | String | 是 | 会话ID |
| nodeId | String | 是 | 节点ID |
| stateData | Map | 是 | 要更新的状态数据 |

---

### 2.3 保存检查点

**功能描述**：在节点执行完成后自动保存检查点。

**业务规则**：
- 每个节点执行完成后触发
- 保存当前状态快照
- 记录已执行节点列表
- 支持覆盖式更新

**检查点数据结构**：
```java
Checkpoint {
    conversationId: String
    nodeId: String
    stateSnapshot: Map<String, Object>
    executedNodeIds: List<String>
    timestamp: Long
    version: Integer
}
```

---

### 2.4 加载检查点恢复执行

**功能描述**：从检查点恢复执行上下文，支持断点续执行。

**业务规则**：
- 根据 conversationId 加载最新检查点
- 恢复状态数据到内存
- 重建依赖追踪器状态
- 标记已执行节点

**应用场景**：
- 人工审核通过后恢复执行
- 系统重启后恢复执行
- 执行失败后重试

---

## 3. 状态数据管理

### 3.1 状态键定义

| 状态键 | 类型 | 说明 |
|--------|------|------|
| user_input | String | 用户输入消息 |
| {{nodeId}}_output | Object | 节点输出结果 |
| messages | List | 对话历史（LLM上下文） |
| final_output | String | 最终输出结果 |
| execution_history | List | 执行历史记录 |

### 3.2 状态合并策略（Reducer）

```java
interface StateReducer {
    Object reduce(String key, Object oldValue, Object newValue);
}

// 示例：列表追加策略
class AppendListReducer implements StateReducer {
    Object reduce(key, oldValue, newValue) {
        if (oldValue instanceof List) {
            ((List) oldValue).addAll((List) newValue);
            return oldValue;
        }
        return newValue;
    }
}

// 示例：覆盖策略
class OverwriteReducer implements StateReducer {
    Object reduce(key, oldValue, newValue) {
        return newValue;
    }
}
```

### 3.3 默认合并规则

| 状态键模式 | 合并策略 |
|------------|----------|
| messages | AppendListReducer |
| execution_history | AppendListReducer |
| *_output | OverwriteReducer |
| 其他 | OverwriteReducer |

---

## 4. 存储设计

### 4.1 存储介质
- **主存储**：Redis（快速读写）
- **持久化**：MySQL（可选，用于历史查询）

### 4.2 Redis 存储结构

```
# 检查点数据
checkpoint:{conversationId} -> JSON(Checkpoint)

# 执行状态
execution:state:{conversationId} -> JSON(ExecutionState)

# 状态数据
context:state:{conversationId} -> HASH(stateData)
```

### 4.3 过期策略
- 检查点数据：7天过期
- 执行状态：执行完成后24小时过期
- 可配置持久化到数据库

---

## 5. 非功能需求

### 5.1 可靠性
- 检查点保存原子性
- 状态恢复一致性
- 支持版本冲突检测

### 5.2 性能
- 快照读取 < 50ms
- 检查点保存 < 100ms
- 支持大状态数据（< 10MB）

### 5.3 安全性
- 状态数据加密存储（可选）
- 访问权限控制

---

## 6. 领域模型

### 6.1 值对象：ExecutionContext

```java
ExecutionContext {
    stateData: ConcurrentHashMap<String, Object>
    reducers: StateReducerRegistry
    
    // 读取状态
    <T> T get(String key, Class<T> type)
    
    // 写入状态
    void put(String key, Object value)
    
    // 合并更新
    void merge(StateUpdate update)
    
    // 创建快照
    Map<String, Object> snapshot()
    
    // 恢复快照
    void restore(Map<String, Object> data)
}
```

### 6.2 端口接口

```java
interface CheckpointRepository {
    // 保存检查点
    void save(Checkpoint checkpoint);
    
    // 加载检查点
    Optional<Checkpoint> load(String conversationId);
    
    // 更新检查点
    void update(String conversationId, Map<String, Object> stateData);
    
    // 删除检查点
    void delete(String conversationId);
}
```

### 6.3 基础设施实现

| 实现类 | 说明 |
|--------|------|
| RedisCheckpointRepository | Redis 实现 |
| MySQLCheckpointRepository | MySQL 实现（备份） |

---

## 7. 依赖关系

### 7.1 对外提供
- ExecutionContext：状态读写能力
- CheckpointRepository：检查点持久化

### 7.2 依赖外部
- Redis：快速存储
- MySQL：持久化存储（可选）
