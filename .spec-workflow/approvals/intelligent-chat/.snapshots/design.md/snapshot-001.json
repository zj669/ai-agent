{
  "id": "snapshot_1768126023849_h6szkvte3",
  "approvalId": "approval_1768126023791_tgcyu2hnc",
  "approvalTitle": "Intelligent Chat Design - Backend Refinement (Direct SSE & Pub/Sub)",
  "version": 1,
  "timestamp": "2026-01-11T10:07:03.849Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# AI-Agent Intelligent Chat Module - Design Document\r\n\r\n## 1. Overview\r\nThe **Intelligent Chat Module** enables real-time interaction between users and the AI Agent workflow. It leverages **Server-Sent Events (SSE)** to stream execution progress, supports a \"Thinking\" mode for visualization of complex reasoning, and provides a **Debug Mode** for detailed execution tracing.\r\n\r\n## 2. Architecture\r\n\r\n### 2.1 Component Interaction\r\n1.  **Client (React)**: Initiates chat, listens to SSE stream, renders messages/thoughts/debug info.\r\n2.  **WorkflowController**: Handles HTTP requests (`POST /start`, `GET /history`), manages SSE emitters.\r\n3.  **SseEventPublisher**: Listens to Domain Events (`NodeStarted`, `NodeCompleted`) and pushes formatted SSE events to the Controller.\r\n4.  **WorkflowNodeExecutionLogRepository**: MySQL persistence for detailed execution logs (Audit Log).\r\n5.  **SchedulerService**: Executes the DAG and publishes Domain Events (already implemented).\r\n\r\n### 2.2 Data Flow\r\n```mermaid\r\nsequenceDiagram\r\n    Client->>WorkflowController (Pod A): POST /api/workflow/execution/start (stream=true)\r\n    WorkflowController (Pod A)->>Redis: Subscribe channel \"workflow:channel:{id}\"\r\n    WorkflowController (Pod A)->>SchedulerService (Pod B): startExecution() (Async)\r\n    \r\n    loop Stream Logic\r\n        SchedulerService (Pod B)->>Redis: Publish \"workflow:channel:{id}\" (NodeStart/Chunk/End)\r\n        Redis->>WorkflowController (Pod A): OnMessage\r\n        WorkflowController (Pod A)-->>Client: SSE Write (Chunk)\r\n        \r\n        Note over SchedulerService (Pod B): Idle/Thinking\r\n        SchedulerService (Pod B)->>Redis: Publish \"ping\" (Heartbeat)\r\n    end\r\n    \r\n    Note right of SchedulerService (Pod B): Incremental Persistence (Per Node)\r\n    SchedulerService (Pod B)->>MySQL: Async Save Log (onNodeComplete)\r\n```\r\n\r\n## 3. Data Models\r\n\r\n### 3.1 Database Schema (MySQL)\r\n\r\n**Table: `workflow_node_execution_log`**\r\nUsed for history and debug details.\r\n\r\n```sql\r\nCREATE TABLE workflow_node_execution_log (\r\n    id BIGINT AUTO_INCREMENT PRIMARY KEY,\r\n    execution_id VARCHAR(64) NOT NULL,\r\n    node_id VARCHAR(64) NOT NULL,\r\n    node_name VARCHAR(128),\r\n    node_type VARCHAR(32),\r\n    render_mode VARCHAR(32) NOT NULL COMMENT 'HIDDEN, THOUGHT, MESSAGE',\r\n    status TINYINT NOT NULL COMMENT '0:Running, 1:Success, 2:Failed',\r\n    inputs JSON, -- Full inputs (sensitive data included)\r\n    outputs JSON, -- Full outputs\r\n    error_message TEXT,\r\n    start_time DATETIME(3),\r\n    end_time DATETIME(3),\r\n    INDEX idx_execution_id (execution_id)\r\n);\r\n```\r\n\r\n### 3.2 Value Objects (Java)\r\n\r\n**`RenderConfig`**\r\n```java\r\npublic class RenderConfig {\r\n    private String mode; // HIDDEN, THOUGHT, MESSAGE\r\n    private String title; // \"Thinking...\", \"Searching...\"\r\n}\r\n```\r\n\r\n**`SseEventPayload`**\r\n```java\r\npublic class SseEventPayload {\r\n    private String executionId;\r\n    private String nodeId;\r\n    private String nodeType;\r\n    private long timestamp;\r\n    private RenderConfig renderConfig;\r\n    \r\n    // Content structure\r\n    private boolean isThought; // true: Update thought block, false: Update main message\r\n    private String content;    // Delta text content\r\n    private Object data;       // For debug inputs/outputs or JSON data\r\n}\r\n```\r\n\r\n## 4. API Design\r\n\r\n### 4.1 SSE Stream (Combined)\r\n*   **Method**: `POST /api/workflow/execution/start`\r\n*   **Content-Type**: `text/event-stream`\r\n*   **Description**: Initiates workflow and immediately returns the SSE stream. Holds connection open.\r\n    *   **Note**: This replaces the split `/start` + `/stream` approach to avoid race conditions.\r\n*   **Mechanism**:\r\n    1.  Generate `executionId` immediately.\r\n    2.  Subscribe `SseEmitter` to Redis channel `workflow:channel:{executionId}`.\r\n    3.  Async call scheduler to start execution.\r\n    4.  Stream events as they arrive from Redis.\r\n    5.  **Timeout**: Set `SseEmitter` timeout to `1800000L` (30 mins) to support long-running nodes.\r\n    6.  Handle timeouts with auto-ping.\r\n\r\n### 4.2 Control API\r\n*   `POST /api/workflow/execution/stop`\r\n    *   **Body**: `{ \"executionId\": \"...\" }`\r\n    *   **Description**: Interrupts a running execution. Sets status to CANCELLED in Redis/DB; Scheduler checks this flag before next node.\r\n\r\n### 4.3 History API\r\n*   `GET /api/workflow/execution/history/{conversationId}`\r\n    *   Response: List of previous executions/messages.\r\n*   `GET /api/workflow/execution/{executionId}/node/{nodeId}`\r\n    *   Response: Full `inputs` and `outputs` from MySQL (for Debug Mode).\r\n\r\n## 5. Security & Visibility\r\n\r\n### 5.1 Visibility Logic\r\nIn `SseEventPublisher`:\r\n```java\r\nif (!debugMode && config.getVisibility() == HIDDEN) {\r\n    return; // Do not push event\r\n}\r\nif (!debugMode) {\r\n    // Mask sensitive inputs/outputs\r\n    payload.setInputs(null); \r\n    payload.setOutputs(filterPublicOutputs(result.getOutputs()));\r\n}\r\n```\r\n\r\n## 6. Implementation Steps\r\n1.  **Infrastructure**: Add Redis Pub/Sub config (`MessageListenerAdapter`, `RedisMessageListenerContainer`).\r\n2.  **Domain**: Update `SseEventPayload` with `isThought` and `content`.\r\n3.  **Infrastructure**: Implement `RedisSsePublisher` (sends to Redis) and `RedisSseSubscriber` (pushes to Emitter).\r\n4.  **Application**: Update `SchedulerService` to support cancellation check.\r\n5.  **Interface**: Refactor `WorkflowController` to support Direct POST Streaming.\r\n",
  "fileStats": {
    "size": 5394,
    "lines": 133,
    "lastModified": "2026-01-11T10:05:18.277Z"
  },
  "comments": []
}