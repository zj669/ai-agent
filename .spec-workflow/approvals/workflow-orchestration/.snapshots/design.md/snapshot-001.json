{
  "id": "snapshot_1768122891156_5au0yu6b2",
  "approvalId": "approval_1768122891103_vawn8nfoy",
  "approvalTitle": "Workflow Orchestration Design",
  "version": 1,
  "timestamp": "2026-01-11T09:14:51.156Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# 设计文档 - 工作流编排模块 (Orchestration Context)\r\n\r\n## 概述\r\n\r\n工作流编排模块（Core Domain）采用 **领域驱动设计 (DDD)** 构建，核心是 `Execution` 聚合根。其主要职责是解析 `WorkflowGraph`，依据拓扑结构调度 `Node`，并通过 **策略模式** (`NodeExecutorStrategy`) 委托基础设施层执行具体业务逻辑（如 LLM 调用、HTTP 请求）。本设计重点支持 **并行调度**、**SpEL 表达式引擎** 和 **高扩展性节点架构**。\r\n\r\n## 架构设计\r\n\r\n### 模块化设计原则 (Modular Design Principles)\r\n- **调度与执行分离**: `SchedulerService` (Domain) 只负责图遍历和状态机；`NodeExecutor` (Infrastructure) 负责业务 API 调用。\r\n- **策略驱动**: 所有节点行为（含控制流）均抽象为策略接口。\r\n- **上下文隔离**: `ExecutionContext` 封装数据读写，提供 SpEL 解析能力。\r\n\r\n### 架构图 (Architecture)\r\n\r\n```mermaid\r\ngraph TD\r\n    subgraph \"Domain Layer (Core)\"\r\n        AggExecution[Execution Aggregate]\r\n        AggExecution --> EntNode[Node Entity]\r\n        AggExecution --> VOContext[ExecutionContext VO]\r\n        AggExecution --> VOCheckpoint[Checkpoint VO]\r\n        \r\n        SvcScheduler[SchedulerService]\r\n        SvcScheduler -->|1. Calculate Indegree| AggExecution\r\n        SvcScheduler -->|2. Get Ready Nodes| AggExecution\r\n        SvcScheduler -->|3. Dispatch| PortExecutor[NodeExecutorStrategy Port]\r\n    end\r\n\r\n    subgraph \"Infrastructure Layer\"\r\n        ImplLlm[LlmNodeExecutorStrategy] -.->|Implements| PortExecutor\r\n        ImplHttp[HttpNodeExecutorStrategy] -.->|Implements| PortExecutor\r\n        \r\n        RepoCheckpoint[RedisCheckpointRepository]\r\n        RepoCheckpoint -.->|Persists| VOCheckpoint\r\n        \r\n        EventPub[SseEventPublisher]\r\n    end\r\n    \r\n    subgraph \"External Services\"\r\n        SpringAI[Spring AI / LLM Service]\r\n        WebClient[WebClient / HTTP]\r\n    end\r\n    \r\n    ImplLlm --> SpringAI\r\n    ImplHttp --> WebClient\r\n```\r\n\r\n## 组件与接口\r\n\r\n### Component 1: Execution Aggregate (聚合根)\r\n- **目的**: 维护工作流执行的一致性边界。\r\n- **职责**:\r\n    - 管理 `ExecutionContext` 状态数据。\r\n    - 记录节点状态 (`NodeStatus`: PENDING, RUNNING, SUCCEEDED, FAILED, SKIPPED, PAUSED)。\r\n    - 生成 `Checkpoint`。\r\n    - 处理 `pause()` 和 `resume()` 逻辑。\r\n- **关键方法**:\r\n    - `start(graph, inputs)`\r\n    - `advance(finishedNodeId, outputs)`\r\n    - `resume(nodeId, inputs)`\r\n\r\n### Component 2: SchedulerService (领域服务)\r\n- **目的**: 核心调度引擎。\r\n- **职责**:\r\n    - **拓扑分析**: 计算节点入度 (In-Degree)。\r\n    - **并行调度**: 识别所有入度为 0 且依赖满足的节点。\r\n    - **循环检测**: 启动时检测 DAG 环。\r\n    - **策略分发**: 根据 `nodeType` 从 `ExecutorFactory` 获取策略并执行。\r\n- **依赖**: `NodeExecutorFactory`, `ExecutionRepository`\r\n\r\n### Component 3: NodeExecutorStrategy (策略接口)\r\n- **位置**: `com.zj.aiagent.domain.workflow.port`\r\n- **接口定义**:\r\n    ```java\r\n    public interface NodeExecutorStrategy<T extends NodeConfig> {\r\n        // 执行节点逻辑\r\n        void execute(Node node, ExecutionContext context);\r\n        // 支持的节点类型\r\n        NodeType getSupportedType();\r\n    }\r\n    ```\r\n- **实现类**:\r\n    - `LlmNodeExecutorStrategy`: 调用 Spring AI。\r\n    - `HttpNodeExecutorStrategy`: 调用 WebClient。\r\n    - `ConditionNodeExecutorStrategy`: 执行路由逻辑。\r\n\r\n### Component 4: ExecutionContext (值对象)\r\n- **目的**: 封装运行时数据与 SpEL 引擎。\r\n- **职责**:\r\n    - 存储 `Map<String, Object> data` (inputs, outputs)。\r\n    - 提供 `resolve(String expression)` 方法，使用 SpEL 解析 `${...}`。\r\n    - 安全沙箱控制（禁止访问 System 类）。\r\n\r\n## 数据模型 (Data Models)\r\n\r\n### Execution Entity\r\n```java\r\npublic class Execution {\r\n    private ExecutionId id;\r\n    private WorkflowGraph graph;\r\n    private ExecutionStatus status;\r\n    private Map<String, NodeStatus> nodeStatuses; // 节点状态表\r\n    private ExecutionContext context;\r\n    // ...\r\n}\r\n```\r\n\r\n### NodeConfig (基类)\r\n```java\r\npublic abstract class NodeConfig {\r\n    private HumanReviewConfig humanReviewConfig; // 通用配置\r\n    private RetryPolicy retryPolicy;             // 重试策略\r\n}\r\n\r\npublic class LlmNodeConfig extends NodeConfig {\r\n    private String model;\r\n    private String promptTemplate; // 支持 SpEL\r\n    // ...\r\n}\r\n```\r\n\r\n## 错误处理 (Error Handling)\r\n\r\n### 场景 1：节点执行失败\r\n- **处理**: \r\n    1. 检查 `RetryPolicy` (maxRetries)。\r\n    2. 若可重试，调度器延迟重新提交任务。\r\n    3. 若耗尽重试次数，标记节点为 `FAILED`。\r\n    4. 检查是否有 `Fallback` 分支（可选），否则标记 Execution 为 `FAILED`。\r\n\r\n### 场景 2：DAG 环路检测\r\n- **处理**: `start()` 时通过 DFS 检测环。\r\n- **影响**: 抛出 `InvalidGraphException`，任务直接拒绝，向用户返回 400 错误。\r\n\r\n## 测试策略\r\n\r\n### Unit Testing\r\n- **SchedulerService**: 构造复杂的 DAG（棱形结构、并行结构），Mock ExecutorStrategy，验证调度顺序和并行度。\r\n- **SpEL Engine**: 测试恶意表达式（如 `T(System).exit(0)`），验证是否被沙箱拦截。\r\n\r\n### Integration Testing\r\n- **Redis Persistence**: 验证 `Checkpoint` 能正确序列化/反序列化到 Redis。\r\n- **End-to-End**: 启动一个包含 Start -> LLM -> End 的完整流程，验证 SSE 事件流和最终输出。\r\n",
  "fileStats": {
    "size": 5578,
    "lines": 145,
    "lastModified": "2026-01-11T09:14:36.859Z"
  },
  "comments": []
}