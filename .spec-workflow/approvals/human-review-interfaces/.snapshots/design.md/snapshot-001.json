{
  "id": "snapshot_1768224800111_fncpm61eu",
  "approvalId": "approval_1768224800063_utm5nqpzz",
  "approvalTitle": "Design for Human Review Interfaces",
  "version": 1,
  "timestamp": "2026-01-12T13:33:20.111Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design: Human Review Interfaces\r\n\r\n## 1. Domain Layer Changes\r\n\r\n### 1.1 `Execution` (Aggregate Root)\r\nAdd method to safely update context while in `PAUSED` state.\r\n\r\n```java\r\npublic void updateContext(Map<String, Object> inputUpdates, Map<String, Object> sharedStateUpdates) {\r\n    if (this.status != ExecutionStatus.PAUSED) {\r\n        throw new IllegalStateException(\"Can only update context when execution is PAUSED\");\r\n    }\r\n    \r\n    if (inputUpdates != null) {\r\n        this.context.getInputs().putAll(inputUpdates);\r\n    }\r\n    \r\n    if (sharedStateUpdates != null) {\r\n        this.context.getSharedState().putAll(sharedStateUpdates);\r\n    }\r\n}\r\n```\r\n\r\n### 1.2 `ExecutionContext`\r\nEnsure `inputs` and `sharedState` are mutable (they are `ConcurrentHashMap` in current impl, so direct access is fine, but encapsulation via `putAll` is cleaner).\r\n\r\n## 2. Application Layer Changes\r\n\r\n### 2.1 `SchedulerService`\r\nAdd transactional method for context updates.\r\n\r\n```java\r\npublic void updateExecutionContext(String executionId, Map<String, Object> inputUpdates, Map<String, Object> sharedStateUpdates) {\r\n    // 1. Lock execution\r\n    // 2. Load Execution\r\n    // 3. execution.updateContext(...)\r\n    // 4. Save Execution\r\n    // 5. Unlock\r\n}\r\n```\r\n\r\nExisting `resumeExecution` in `SchedulerService` is already sufficient:\r\n```java\r\npublic void resumeExecution(String executionId, String nodeId, Map<String, Object> additionalInputs)\r\n```\r\nIt takes `additionalInputs` which effectively act as feedback from the human review.\r\n\r\n## 3. Interface Layer Changes\r\n\r\n### 3.1 `WorkflowController`\r\n\r\n#### New DTOs\r\n```java\r\n@Data\r\npublic class UpdateContextRequest {\r\n    private Map<String, Object> inputs;\r\n    private Map<String, Object> sharedState;\r\n}\r\n\r\n@Data\r\npublic class ResumeExecutionRequest {\r\n    private String nodeId;\r\n    private Map<String, Object> inputs; // Merged into node inputs or global context depending on logic\r\n}\r\n```\r\n\r\n#### New Endpoints\r\n\r\n**GET /api/workflow/execution/{executionId}/context**\r\n```java\r\n@GetMapping(\"/{executionId}/context\")\r\npublic ResponseEntity<ExecutionContextDTO> getExecutionContext(@PathVariable String executionId) {\r\n    // 1. Repo.findById\r\n    // 2. Return execution.getContext() mapped to DTO\r\n}\r\n```\r\n\r\n**PUT /api/workflow/execution/{executionId}/context**\r\n```java\r\n@PutMapping(\"/{executionId}/context\")\r\npublic ResponseEntity<Void> updateExecutionContext(\r\n    @PathVariable String executionId,\r\n    @RequestBody UpdateContextRequest request\r\n) {\r\n    schedulerService.updateExecutionContext(executionId, request.getInputs(), request.getSharedState());\r\n    return ResponseEntity.ok().build();\r\n}\r\n```\r\n\r\n**POST /api/workflow/execution/{executionId}/resume**\r\n```java\r\n@PostMapping(\"/{executionId}/resume\")\r\npublic ResponseEntity<Void> resumeExecution(\r\n    @PathVariable String executionId,\r\n    @RequestBody ResumeExecutionRequest request\r\n) {\r\n    schedulerService.resumeExecution(executionId, request.getNodeId(), request.getInputs());\r\n    return ResponseEntity.ok().build();\r\n}\r\n```\r\n\r\n## 4. Security & Validation\r\n- Ensure `executionId` belongs to the user (out of scope for now as per minimal viable changes, but good to note).\r\n- Redis Locks are crucial for `updateExecutionContext` to prevent race conditions with async node completions (though mostly paused, confirming lock is safe).\r\n",
  "fileStats": {
    "size": 3358,
    "lines": 105,
    "lastModified": "2026-01-12T13:33:01.151Z"
  },
  "comments": []
}